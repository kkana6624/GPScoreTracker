# DDRスコア管理アプリケーション ドメイン駆動設計仕様書

* **ドキュメントバージョン:** 1.0
* **作成日:** 2025年10月12日
* **作成者:** Gemini & Project Owner

---

## 1. プロジェクトの全体像とアーキテクチャ

### 1.1. はじめに

#### 1.1.1. 目的

本ドキュメントは、DanceDanceRevolution (DDR) のスコアを管理するデスクトップアプリケーションの開発における、ドメイン駆動設計（DDD）に基づいた設計仕様を定義することを目的とする。

このアプリケーションは、プレイヤーが自身のスコアを記録・追跡し、成長を可視化することを支援する。本ドキュメントは、開発チームが共通の理解を持ち、一貫性のある高品質なソフトウェアを構築するための礎となる。

#### 1.1.2. 設計アプローチ

本プロジェクトでは、複雑なビジネスロジックを適切にモデル化し、長期的な保守性と拡張性を確保するため、以下の設計アプローチを組み合わせる。

* **ドメイン駆動設計 (DDD):** ビジネス領域（DDRのスコアリング）の専門知識とルールを、ソフトウェアの核となるドメインモデルに直接反映させる。
* **クリーンアーキテクチャ:** 関心の分離を徹底し、ビジネスロジック（ドメイン）が外部の技術詳細（UI, データベース, 外部API）に依存しない、安定したソフトウェア構造を目指す。
* **CQRS (コマンド・クエリ責務分離):** データの状態を変更する処理（コマンド）と、データを読み取る処理（クエリ）のパスを明確に分離し、それぞれの処理を最適化する。
* **テスト駆動開発 (TDD):** 実装コードを書く前に、そのコードが満たすべき仕様をテストコードとして先に記述する。これにより、品質の向上、バグの早期発見、リファクタリングの安全性を確保する。

#### 1.1.3. 技術スタック概要

* **UI:** WinUI 3
* **データベース:** Entity Framework Core (コードファースト)
* **クエリ言語:** LINQ (Language-Integrated Query)
* **画像認識:** Google Gemini API
* **テストフレームワーク:** xUnit (MSTest, NUnitも選択肢)

### 1.2. アーキテクチャ概要

#### 1.2.1. レイヤードアーキテクチャ

本アプリケーションは、クリーンアーキテクチャの原則に基づき、以下の4つの主要なレイヤーで構成される。依存関係は常に外側のレイヤーから内側のレイヤーへと一方向に向かう。

1.  **Domain (Core) Layer:**
    * アプリケーションの「心臓部」。ビジネスの核となるエンティティ、値オブジェクト、ドメインサービス、リポジトリインターフェースを定義する。他のどのレイヤーにも依存しない。
2.  **Application Layer:**
    * ユースケースを実現する層。UIからのリクエストを受け取り、ドメインオブジェクトを操作してビジネスフローを実行する。DTOや、インフラ層が実装すべきインターフェースを定義する。
3.  **Infrastructure (Persistence/Repository) Layer:**
    * データベースアクセス（EF Core）、外部API（Gemini API）との通信など、外部の技術的な関心事を担当する。Domain層やApplication層で定義されたインターフェースを実装する。
4.  **Presentation (UI) Layer:**
    * ユーザーとのインターフェースを担当する。本アプリケーションではWinUI 3とMVVMパターンを採用する。

#### 1.2.2. CQRS (コマンド・クエリ責務分離)

データの書き込みと読み込みで、最適なデータフローとモデルを使用する。

* **コマンド（書き込み）パス:**
    * 新規スコアの登録など、データの状態を変更する処理。
    * 必ずApplicationサービスを経由し、ドメインモデル（エンティティ、値オブジェクト）をロードしてビジネスルールを厳格に適用した上で、リポジトリを通じて永続化する。データの整合性を最優先する。

* **クエリ（読み込み）パス:**
    * 楽曲一覧の表示など、データを表示するための処理。
    * ドメインモデルを介さず、EF Coreのプロジェクション（`Select`句）などを活用して、UIが表示したい形に最適化されたDTO（Data Transfer Object）を直接データベースから構築する。パフォーマンスを最優先する。

#### 1.2.3. テスト駆動開発 (TDD)

品質の高いソフトウェアを効率的に構築するため、TDDのサイクル（Red → Green → Refactor）を実践する。

* **単体テスト:** Domain層のビジネスルールやApplication層のユースケースフローを、外部依存から切り離して検証する。
* **結合テスト:** Infrastructure層がデータベースや外部APIと正しく連携できるかを検証する。


## 2. ユビキタス言語

本セクションでは、プロジェクト関係者（開発者、利用者）が共通の理解を持つために定義された用語集を定義する。これらの用語は、ソースコード（クラス名、メソッド名、変数名など）に直接反映されるべきである。

* **ユーザープロファイル (User Profile)**
    * アプリケーションの利用者情報を管理する単位。スコア記録はすべてこのプロファイルに紐づく。`プレイヤー (Player)`と同義。

* **キャプチャ (Capture)**
    * ホットキーによって取得された、DDRのリザルト画面を含むスクリーンショット画像。解析待ちの状態にある一時的なデータ。

* **解析ジョブ (Analysis Job)**
    * `キャプチャ`をGemini APIに送信し、スコア情報を抽出する一連の処理タスク。通常はキューで管理される。

* **解析結果 (Analysis Result)**
    * `解析ジョブ`によって`キャプチャ`から抽出された、構造化された`スコア`データ。サムネイル画像と関連付けられ、ユーザーによる確認・修正を経てDB登録されるまでの一時的なデータ。

* **楽曲 (Song)**
    * DDRに収録されている曲。曲名、アーティスト名などの固有情報を持つ。

* **譜面 (Chart)**
    * 特定の`楽曲`と`難易度`の組み合わせ。`レベル`を持ち、実際にプレイする対象となる。

* **難易度 (Difficulty)**
    * `譜面`の難易度カテゴリ。`BEGINNER`, `BASIC`, `DIFFIC-ULT`, `EXPERT`, `CHALLENGE`のいずれかの値をとる。

* **レベル (Level)**
    * `譜面`の難易度を具体的に示す1から19までの数値。

* **スコア (Score)**
    * 1回のプレイ結果の詳細をまとめて表現する**値オブジェクト**。以下の属性で構成される。
    * **Points:** 100万点満点の数値。会話やUI上では単に「スコア」と呼ばれることが多い。
    * **EXスコア (EX Score):** 判定ごとの配点に基づくスコア。
    * **ランク (Rank):** `AAA`, `AA`などの評価ランク。
    * **判定 (Judgements):** Marvelous, Perfect, Greatなどの判定ごとの回数。
    * **最大コンボ数 (Max Combo):** プレイ中に達成した最大のコンボ数。
    * **クリアタイプ (Clear Type):** 達成状況を示す種別。`FAILED`, `CLEARED`, `FULL_COMBO`, `PERFECT_FULL_COMBO`などの値をとる。

* **スコア記録 (Score Record)**
    * データベースに永続化された、1回ごとのプレイ履歴。誰が(`User Profile`)、いつ、どの`譜面`をプレイし、どのような`スコア`だったかを記録する不変の事実。

* **自己ベスト (Personal High Score)**
    * `ユーザープロファイル`ごと、`譜面`ごとに記録される、個人の最高`スコア`。`Points`を基準に更新される。

* **トップスコア (Top Score)**
    * `譜面`ごとに、全`ユーザープロファイル`の中で最も高い`スコア`。システム全体の最高記録。


## 3. ドメインモデルの詳細

本セクションでは、システムの核となるビジネスルールを表現するオブジェクト（エンティティ、値オブジェクト）と、それらの永続化を抽象化するインターフェース（リポジトリ）について詳細に定義する。

### 3.1. エンティティ (Entities)

エンティティは、一意な識別子（ID）を持ち、ライフサイクルを通じて状態が変化するオブジェクトである。その同一性は、属性ではなくIDによって保証される。

#### `Player` (プレイヤー)
システムにスコアを記録するユーザーを表す。
- `PlayerId` (ID): プレイヤーの一意な識別子
- `PlayerName` (string): プレイヤー名

#### `Song` (楽曲)
DDRに収録されている楽曲を表す。
- `SongId` (ID): 楽曲の一意な識別子
- `Title` (string): 楽曲のタイトル
- `Artist` (string): アーティスト名
- `Status` (SongStatus): 楽曲の状態 (`Active`, `Deleted`など)。論理削除に使用する。

#### `ScoreRecord` (スコア記録)
プレイヤーによる1回ごとのプレイ履歴を表す。一度記録されたら変更されない。
- `ScoreRecordId` (ID): プレイ履歴の一意な識別子
- `PlayerId` (ID): プレイしたプレイヤーのID
- `Chart` (Value Object): プレイした譜面
- `Score` (Value Object): プレイ結果のスコア詳細
- `PlayedAt` (DateTime): プレイした日時

#### `PersonalHighScore` (自己ベスト)
プレイヤーごと、譜面ごとの自己ベスト記録を表す。
- `PersonalHighScoreId` (ID): 自己ベスト記録の一意な識別子
- `PlayerId` (ID): 記録を保持するプレイヤーのID
- `Chart` (Value Object): 対象となる譜面
- `Score` (Value Object): 自己ベストのスコア詳細
- `AchievedAt` (DateTime): この記録を達成した日時

#### `TopScore` (トップスコア)
譜面ごとの、全プレイヤー中での最高記録を表す。
- `TopScoreId` (ID): トップスコア記録の一意な識別子
- `PlayerId` (ID): この記録を達成したプレイヤーのID
- `Chart` (Value Object): 対象となる譜面
- `Score` (Value Object): トップスコアのスコア詳細
- `AchievedAt` (DateTime): この記録を達成した日時

### 3.2. 値オブジェクト (Value Objects)

値オブジェクトは、その属性の組み合わせによって識別される**不変 (Immutable)**なオブジェクトである。IDを持たず、一度作成されたらその値は変更されない。また、自身の不変条件（ルール）を保証する責務を持つ。

#### `Chart` (譜面)
プレイ対象となる、特定の楽曲の特定の難易度を表す。
- `SongId` (ID): 楽曲のID
- `Difficulty` (enum): 難易度 (`BEGINNER`など)
- `Level` (Value Object): レベル

#### `Level` (レベル)
譜面の難易度を示す数値。
- `Value` (int): レベルの値
- **不変条件:** `Value`は`1`から`19`の範囲内でなければならない。このオブジェクトは、不正な値で作成されることを許容しない。

#### `Score` (スコア)
1回のプレイ結果の詳細をまとめて表現する。
- `Points` (int): 100万点満点の数値
- `EXScore` (int): EXスコア
- `Rank` (enum): 評価ランク (`AAA`など)
- `Judgements` (Value Object): 判定ごとの回数を保持するオブジェクト (`Marvelous`, `Perfect`の数など)
- `MaxCombo` (int): 最大コンボ数
- `ClearType` (enum): クリア種別 (`FULL_COMBO`など)

### 3.3. 集約 (Aggregates) とリポジトリインターフェース

**集約 (Aggregate)** は、関連するエンティティと値オブジェクトをまとめた、データ変更の一貫性を保つための単位である。本設計では、シンプルさを保つため、各エンティティをそれぞれ独立した集約のルート（Aggregate Root）として扱う。

**リポジトリ (Repository)** は、集約の永続化（保存や読み込み）を抽象化するインターフェースである。ドメイン層は、データベースなどの具体的な永続化技術を知ることなく、このインターフェースを通じてデータの操作を行う。

#### リポジトリインターフェース一覧 (`Domain`レイヤーに定義)
- `IPlayerRepository`
- `ISongRepository`
- `IScoreRecordRepository`
- `IPersonalHighScoreRepository`
- `ITopScoreRepository`

## 4. 主要なユースケースと実装方針

本セクションでは、システムの主要な機能（ユースケース）と、それを実現するためのアプリケーションサービスを中心とした実装方針を定義する。ユーザーの操作フローに基づき、スコア登録までの流れを複数のユースケースに分割して定義する。

### 4.1. アプリケーション起動とプロファイル選択

アプリケーションを起動し、操作対象となるユーザープロファイルを選択する。

* **担当コンポーネント:** `UserProfileApplicationService`, アプリケーションのセッション管理サービス
* **処理フロー:**
    1.  **[UI]** アプリケーションが起動し、ユーザープロファイルの選択画面（または新規作成画面）を表示する。
    2.  **[Application]** `UserProfileApplicationService.GetAllProfiles()`を呼び出し、既存のプロファイル一覧を取得して画面に表示する。
    3.  **[UI]** ユーザーがリストから自身のプロファイルを選択する。
    4.  **[Application]** 選択された`UserProfile`を、アプリケーションの生存期間中保持するセッション情報として格納する。以降の操作は、すべてこのプロファイルに紐づいて実行される。
    5.  **[UI]** メイン画面に遷移する。

### 4.2. 画面キャプチャと解析ジョブのキューイング

ホットキー入力によりリザルト画面をキャプチャし、非同期解析のためのジョブキューに追加する。

* **担当コンポーネント:** `CaptureApplicationService`, UI層のホットキー監視機能
* **処理フロー:**
    1.  **[UI]** メイン画面表示後、システムはバックグラウンドでホットキー入力を待機する。
    2.  **[UI]** ユーザーが指定されたホットキーを押すと、画面全体のスクリーンショットが撮影される。
    3.  **[UI → Application]** 撮影された画像データが`CaptureApplicationService.QueueCaptureForAnalysis(imageData)`に渡される。
    4.  **[Application]** サービスは画像データを一時フォルダにファイルとして保存し、そのファイルパスを含む新しい`解析ジョブ`を作成する。
    5.  **[Application]** 作成された`解析ジョブ`を、非同期処理のためのキュー（Queue）に追加する。
    6.  **[Application → UI]** UIに通知し、メイン画面の「解析待ちリスト」に新しい`キャプチャ`が追加されたことを表示する。

### 4.3. 非同期でのスコア解析

バックグラウンドで解析ジョブを処理し、スコアデータを抽出する。

* **担当コンポーネント:** `AnalysisJobProcessorService` (バックグラウンドワーカー), `IScoreOcrService`
* **処理フロー:**
    1.  **[Application/Infrastructure]** `AnalysisJobProcessorService`が、ジョブキューを常時監視する。
    2.  **[Application]** キューに新しい`解析ジョブ`があれば、一つ取り出す。
    3.  **[Application → Infrastructure]** `IScoreOcrService`（実体は`GeminiScoreOcrService`）を呼び出し、`キャプチャ`画像の解析を依頼する。
    4.  **[Application]** 解析に成功した場合、構造化された`Score`データを取得し、`解析結果`を`Success`ステータスで作成する。
    5.  **[Application]** 解析に失敗した場合（例: Gemini APIエラー）、エラー情報を取得し、`解析結果`を`Failure`ステータスと`FailureReason`（失敗理由）付きで作成する。
    6.  **[Application]** `キャプチャ`画像のサムネイルを生成し、`解析結果`と紐付けて一時的に保存する。
    7.  **[Application → UI]** UIに通知し、メイン画面の「解析待ちリスト」からアイテムを削除し、「解析済みリスト」に新しい`解析結果`を表示する。`Failure`ステータスの場合は、その旨がわかるように表示する。

### 4.4. 解析結果の確認、手動修正、および単一登録

ユーザーが解析結果を確認し、必要に応じて手動で修正した上で、最終的なスコアをデータベースに登録する。

* **担当コンポーネント:** `ScoreRegistrationApplicationService`, `SongApplicationService`
* **処理フロー:**
    1.  **[UI]** ユーザーが「解析済みリスト」から任意の`解析結果`を選択する。
    2.  **[UI]** `キャプチャ`画像と、解析された`Score`データが入力された編集フォームを持つ詳細画面を表示する。`Failure`ステータスのアイテムの場合、失敗理由も表示する。
    3.  **[UI]** ユーザーは、楽曲DBの情報を元にした検索機能やドロップダウンリストを用いて、対象の`譜面`を正確に選択する。
    4.  **[UI]** ユーザーは表示された`Score`内容を確認し、もし解析結果に誤りがあれば、点数や判定の数などを手動で修正する。
    5.  **[UI]** ユーザーが「登録」ボタンを押す。
    6.  **[UI → Application]** 最終的な`Score`データ、現在の`UserProfile`、そしてユーザーが選択した`Chart`情報が`ScoreRegistrationApplicationService.RegisterScore(...)`に渡される。
    7.  **[Application]** サービスはまず、**重複登録チェック**を実行する（例: 1分以内に同一プロファイル・同一譜面・同一Score内容の記録が存在しないか確認）。重複の可能性がある場合、`DuplicateScoreException`をスローし、UIはユーザーに確認を求める。
    8.  **[Application]** チェックを通過後、サービスは**ドメインロジック（自己ベスト・トップスコアの比較更新）**を実行し、リポジトリを介して`ScoreRecord`等を永続化する。
    9.  **[Application]** 登録成功後、元となった`キャプチャ`画像と`解析結果`を一時領域から削除する。
    10. **[Application → UI]** UIに通知し、「解析済みリスト」から該当アイテムを削除する。

### 4.5. 解析結果の一括登録

複数の解析結果を、詳細確認画面を経由せずにまとめてデータベースに登録する。

* **担当コンポーネント:** `ScoreRegistrationApplicationService`
* **処理フロー:**
    1.  **[UI]** ユーザーが「解析済みリスト」で複数のアイテム（`Success`ステータスのもののみ）を選択し、「一括登録」ボタンを押す。
    2.  **[UI → Application]** 選択された`解析結果`のリストが`ScoreRegistrationApplicationService.RegisterMultipleScores(...)`に渡される。
    3.  **[Application]** サービスはリスト内の各`解析結果`についてループ処理を行う。
        a.  解析された`Score`データと`Chart`情報を信頼し、手動修正なしで登録処理（ユースケース4.4のステップ7〜9と同様）を実行する。
    4.  **[Application → UI]** UIに処理結果（例：「3件中3件の登録に成功しました」）を通知し、リストから成功したアイテムを削除する。

### 4.6. キャプチャまたは解析結果の削除

ユーザーの操作により、不要になったキャプチャや解析結果をリストから削除する。

* **担当コンポーネント:** `CaptureApplicationService`
* **処理フロー:**
    1.  **[UI]** ユーザーが「解析待ちリスト」または「解析済みリスト」で一つ以上のアイテムを選択し、「削除」ボタンを押す。
    2.  **[UI → Application]** 削除対象のアイテムIDが`CaptureApplicationService.DeleteItems(...)`に渡される。
    3.  **[Application]** サービスはIDに基づき、該当する`キャプチャ`画像ファイルや`解析結果`の一時データを物理的に削除する。
    4.  **[Application → UI]** UIに通知し、リストから該当アイテムを削除する。


## 5. プロジェクト構成とテスト戦略

本セクションでは、C#/.NETにおける具体的なソリューションとプロジェクトの構成、およびTDD（テスト駆動開発）を実践するためのテストプロジェクトの構成と役割について定義する。

### 5.1. ソリューション構成

クリーンアーキテクチャのレイヤー構造を、物理的なプロジェクトとして分離する。ソースコードとテストコードは、見通しを良くするためにソリューションフォルダで管理する。


```
DdrScoreTracker.sln
│
├── 📁 src/ (ソースコード用ソリューションフォルダ)
│   ├── DdrScoreTracker.Domain/
│   ├── DdrScoreTracker.Application/
│   ├── DdrScoreTracker.Infrastructure/
│   └── DdrScoreTracker.WinUi/
│
└── 📁 tests/ (テストコード用ソリューションフォルダ)
├── DdrScoreTracker.Domain.Tests/
├── DdrScoreTracker.Application.Tests/
└── DdrScoreTracker.Infrastructure.Tests/
```


### 5.2. 各プロジェクトの役割と依存関係

* **`DdrScoreTracker.Domain`:**
    * アプリケーションの「心臓部」。エンティティ、値オブジェクト、リポジトリインターフェースなど、ビジネスの核となるルールと概念を定義する。

* **`DdrScoreTracker.Application`:**
    * ユースケースを実現する「調整役」。UIからの指示を受け、ドメインオブジェクトを操作してビジネスフローを実行する。インフラ層が実装すべきインターフェースもここで定義する。

* **`DdrScoreTracker.Infrastructure`:**
    * データベース（EF Core）や外部API（Gemini API）など、技術的な詳細を実装する「道具箱」。`Domain`層や`Application`層で定義されたインターフェースを実装する。

* **`DdrScoreTracker.WinUi`:**
    * ユーザーが直接触れる「顔」。ユーザーとの対話に責任を持ち、`Application`層のサービスを呼び出す。

**依存関係のルール:**
依存関係の流れは常に**外側から内側へ**と一方向になり、ドメインの独立性を保証します。

* `DdrScoreTracker.WinUi` は `DdrScoreTracker.Application` に依存します。
* `DdrScoreTracker.Infrastructure` は `DdrScoreTracker.Application` に依存します。
* `DdrScoreTracker.Application` は `DdrScoreTracker.Domain` に依存します。
* `DdrScoreTracker.Domain` は、ソリューション内のどのプロジェクトにも依存しません。

### 5.3. テスト戦略

品質と保守性を確保するため、TDD（テスト駆動開発）を実践する。各レイヤーの特性に応じて、適切な種類のテストを配置する。

* **`DdrScoreTracker.Domain.Tests` (単体テスト):**
    * **目的:** ドメインオブジェクトが持つビジネスルールが正しく動作することを検証する。
    * **特徴:** 外部依存が一切なく、高速に実行できる。モックは基本的に不要。

* **`DdrScoreTracker.Application.Tests` (単体テスト):**
    * **目的:** アプリケーションサービスのユースケース（処理フロー）が正しく動作することを検証する。
    * **特徴:** リポジトリや外部サービスのインターフェースを**モック（偽物）**に差し替えて、サービス単体のロジックをテストする。

* **`DdrScoreTracker.Infrastructure.Tests` (結合テスト):**
    * **目的:** データベースや外部APIとの連携が正しく動作することを検証する。
    * **特徴:** EF Coreのインメモリデータベースや、モック化したHTTPサーバーなどを使い、実際の外部環境に近い状態でテストを行う。

#### 5.3.1. テスト容易性を高める設計原則

* **依存性の注入 (Dependency Injection - DI):**
    * クラスは、依存するオブジェクトを自身で`new`するのではなく、コンストラクタ経由で**インターフェース**として受け取る。これにより、テスト時に本物の実装をモックに容易に差し替えることが可能になる。これはテスト駆動開発を実践する上での絶対的な要件である。

* **インターフェースへの依存:**
    * レイヤー間の境界を越える通信は、必ずインターフェースを介して行う。これにより、UIはDBの実装を知る必要がなくなり、ドメインはUIの存在を知る必要がなくなる。

    ## 6. 実装ガイドライン

本セクションでは、ここまでに定義したアーキテクチャと設計原則を実際のコードに反映させるための、具体的な実装上の指針やベストプラクティスを定義する。

### 6.1. ドメインモデルの実装

* **値オブジェクト (Value Object) は不変(Immutable)かつ自己検証的であること**
    * すべてのプロパティは `get` のみ、または `private set` / `init` とし、外部から変更できないようにする。これは **関数型言語の不変性（Immutability）の考え方** を取り入れるもので、予期せぬ副作用を防ぎ、システムの予測可能性を高める。
    * オブジェクトが存在するための絶対的なルール（不変条件）は、コンストラクタまたは静的ファクトリメソッド内で検証し、不正な値の場合は例外をスローする。

    ```csharp
    // Level.cs in DdrScoreTracker.Domain/ValueObjects/
    public class Level
    {
        public int Value { get; private set; }

        public Level(int value)
        {
            if (value < 1 || value > 19)
            {
                // 不変条件に違反する場合は、オブジェクトの作成を許可しない
                throw new ArgumentOutOfRangeException(nameof(value), "Level must be between 1 and 19.");
            }
            this.Value = value;
        }
    }
    ```

* **エンティティの振る舞い**
    * エンティティ自身の状態のみに依存するビジネスロジックは、エンティティのメソッドとして実装する。
    * 例: `Song`エンティティの`MarkAsDeleted()`メソッドは、自身の`Status`プロパティを変更する。

### 6.2. データアクセスとリポジトリ

* **Entity Framework Coreによるコードファーストアプローチを採用する**
    * `Infrastructure`層のリポジトリクラスは、EF Coreの**コードファースト**アプローチを用いて実装する。C#で定義されたドメインエンティティ（`Song`など）がデータベースのスキーマの正となり、マイグレーション機能を通じてデータベース構造を管理する。

* **クエリはDTOへ直接プロジェクションする**
    * 読み取り専用のクエリでは、パフォーマンス向上のため、EF Coreの`Select`句を使ってドメインエンティティを介さずに直接DTOを構築する。

    ```csharp
    // SongRepository.cs in DdrScoreTracker.Infrastructure/Persistence/Repositories/
    public async Task<List<SongListItemDto>> GetSongListItems()
    {
        return await _context.Songs
            .AsNoTracking() // 読み取り専用クエリでは追跡不要
            .Where(s => s.Status == SongStatus.Active)
            .Select(s => new SongListItemDto
            {
                SongId = s.SongId,
                SongTitle = s.Title,
                // ... 他のプロパティのマッピング
            })
            .ToListAsync();
    }
    ```

### 6.3. アプリケーションサービスとDI

* **依存性の注入 (DI) を徹底する**
    * アプリケーションサービスなどのクラスは、依存するコンポーネント（リポジトリなど）をコンストラクタでインターフェースとして受け取る。クラス内で`new`によるインスタンス化は行わない。

* **トランザクション管理**
    * 複数の書き込み処理を伴う単一のユースケースは、アプリケーションサービス層でトランザクション境界を管理する。

### 6.4. 非同期処理と一時データ

* **バックグラウンド処理の実装**
    * `キャプチャ`画像の非同期解析は、`Microsoft.Extensions.Hosting.BackgroundService`を継承したクラスで実装する。
    * 解析ジョブのキューイングには、スレッドセーフな生産者/消費者パターンを容易に実現できる`System.Threading.Channels.Channel<T>`の利用を推奨する。

* **一時データの保存場所**
    * `キャプチャ`画像などの容量の大きいファイルは、インメモリではなく、アプリケーション専用の一時フォルダ（例: `%LOCALAPPDATA%`配下）に**ファイルとして保存**する。
    * 画像へのパスや解析状態といった軽量なメタデータは、インメモリで管理する。
    * アプリケーションの起動時または終了時に、登録されずに残っている古い一時ファイルをクリーンアップする処理を実装する。

### 6.5. エラーハンドリング

* **ドメイン層:** ビジネスルールに反する操作が行われた場合は、`ArgumentOutOfRangeException`やカスタム例外（例: `DuplicateScoreException`）をスローする。
* **アプリケーション層:** リポジトリやドメインオブジェクトからスローされた例外をキャッチし、UI層が解釈しやすいアプリケーション固有の例外に変換するか、処理結果を示すオブジェクトとしてUIに返す。
* **UI層:** アプリケーション層から受け取った結果や例外に基づき、ユーザーにエラーメッセージや確認ダイアログを表示する。

### 6.6. コーディングスタイル

* **関数型言語の考え方の導入**
    * コードの品質と予測可能性を高めるため、以下の関数型言語の考え方を積極的に取り入れる。
    * **1. 不変性 (Immutability) の重視:** 上述の通り、特に値オブジェクトは不変とし、一度作成されたインスタンスの状態が決して変わらないことを保証する。
    * **2. 副作用の分離:** ロジックを、計算のみを行う純粋な部分と、状態の変更（DBへの書き込みなど）を行う副作用のある部分に意識的に分離する。CQRSの設計はこの原則に沿っている。
    * **3. 式ベースのプログラミング:** `for`ループのような命令的な文よりも、LINQのような宣言的で式ベースの記述を優先する。これにより、コードの意図が明確になり、可読性が向上する。

## 7. エラー定義

本セクションでは、アプリケーション内で発生しうる主要なエラーを定義し、エラーコードを割り当てる。これにより、一貫性のあるエラーハンドリングを実装する。

| エラーコード | 例外クラス (C#) | デフォルトメッセージ | 主な発生シナリオ | 主な対処法 |
|:---|:---|:---|:---|:---|
| **Domain Layer** | | | | |
| `DOM_VAL_001` | `ArgumentOutOfRangeException` | レベルは1から19の間でなければなりません。 | 不正な値で`Level`値オブジェクトを生成しようとした。 | 開発時のバグ。基本的には発生しない想定。ログ記録。 |
| `DOM_VAL_002` | `ArgumentOutOfRangeException` | Pointsは0から1,000,000の間でなければなりません。 | 不正な値で`Score`値オブジェクトを生成しようとした。 | 開発時のバグ。ユーザー入力はApp層で検証済みのはず。 |
| **Application Layer** | | | | |
| `APP_BIZ_001` | `DuplicateScoreException` | 短時間のうちに、類似したスコアが既に登録されています。 | スコア登録時に、1分以内の重複データが検知された。 | UIで確認ダイアログを表示し、ユーザーに強制登録の可否を問う。 |
| `APP_BIZ_002` | `ChartNotFoundException` | 選択された譜面が見つかりませんでした。 | スコア登録時に、指定された`Chart`がDBに存在しない。 | UIでエラーメッセージ表示。ユーザーに譜面の再選択を促す。 |
| `APP_BIZ_003` | `UserProfileNotFoundException` | 現在のユーザープロファイルが見つかりません。 | アプリケーションのセッション情報が不正な状態で操作が行われた。 | UIでエラーメッセージ表示。プロファイル選択画面に戻す。 |
| **Infrastructure Layer** | | | | |
| `INF_OCR_001` | `OcrFailureException` | 画像解析に失敗しました。 | Gemini APIがエラーを返した、または解析不能な画像だった。 | `解析結果`を`Failure`ステータスで作成し、UIに理由を表示する。ユーザーに再試行または削除を促す。 |
| `INF_FS_001` | `CaptureStorageException` | キャプチャ画像の保存に失敗しました。 | ディスク容量不足、または書き込み権限がない。 | UIでエラーメッセージ表示。ユーザーにディスク空き容量や権限の確認を促す。 |
| `INF_DB_001` | `DatabaseAccessException` | データベースへのアクセスに失敗しました。 | DB接続エラー、または予期せぬDB関連の問題。 | UIで汎用的なエラーメッセージを表示し、ログに詳細を記録する。リトライを促す。 |